#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     l1,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     l2,            tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     r1,            tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     r2,            tmotorTetrix, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

//#pragma debuggerWindows("joystickSimple"); //window showing what buttons are being pressed
																					 //on the controller




task main() //main task
{

	nMotorEncoder[r1]= 0;
	nMotorEncoder[r2]= 0;
	nMotorEncoder[l1]= 0;
	nMotorEncoder[l2]= 0;

	nMotorEncoderTarget[r1]=2880;
	nMotorEncoderTarget[r2]=2880;
	nMotorEncoderTarget[l1]=2880;
	nMotorEncoderTarget[l2]=2880;

	motor[r1]= 10;
	motor[r2]= 10;
	motor[l1]= 10;
	motor[l2]= 10;

	while((nMotorRunState[r1]!=runStateIdle)&&
	(nMotorRunState[r2]!=runStateIdle)&&
	(nMotorRunState[l1]!=runStateIdle)&&
	(nMotorRunState[l2]!=runStateIdle))
	{
		wait1Msec(1);
	}

		while (true) //infinite while loop
 		{
 			getJoystickSettings(joystick); //getting joystick inputs
  		int x = joystick.joy1_x2;//*(100/127);// the x value to the robot will be the x value of the right joystick on the first pad;
			int y = joystick.joy1_y2;//*(100/127);//the y value to the robot will be the y value of the right joystick on the first pad;
			int rot = joystick.joy1_x1;//*(100/127);//the rotation value to the robot will be the x value of the left joystick on the first pad
			//the 100/127 is scaling because the controller goes up to 127, but motor power only goes to 100;
			float half = 0.3;


			//code from RobotC forum
		  motor[l1] = (-x + y + rot)*half;// motor power for the left front motor is x + y + rotation
      motor[r1] = (x + y - rot)*half;//motor power for the right front motor is -x + y - rotation
     	motor[l2] = (x + y + rot)*half;//motor power for the left back motor is -x + y + rotation
      motor[r2] = (-x + y - rot)*half;//motor power for the right back motor is x + y - rotation



		}
}
